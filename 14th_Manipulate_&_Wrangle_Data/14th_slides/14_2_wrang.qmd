---
title: "Day 3, Part 2: <br>Wrangling Data Using Conditionals and Iteration"
authors: Brennan Terhune-Cotter and Matt Dye
format: 
  revealjs:
    smaller: false
    theme: [simple, custom.scss]
    footer: "[https://github.com/brennangitsit/2023_IAM3_R](https://github.com/brennangitsit/2023_IAM3_R)"
editor: visual
global_packages:
  - dplyr
  - tidyverse
execute:
  echo: true
---

## Agenda

1.  Vectors

2.  %in%

3.  Conditionals: case_when() and if_else()

4.  Iteration: for loops and map()

# Vectors

## Vectors

-   Vectors are very simple but can get very complicated. They form the core of a lot of things you can do with R

-   Vectors are simply a *list* of *items that are the same type*

-   Often, you will want to work with columns in a dataframe as vectors

    ::: {.callout-important style="text-align: center" appearance="minimal"}
    **variables in a dataframe == columns == vectors**

    **a dataframe is just a collection of (named) vectors with the same length**
    :::

## Lists

-   A type of vector which is more flexible

    -   A "collection" of objects or variables

    -   Vectors are useful for simplicity; lists are useful for many other things

-   Elements in a list can contain any type of R object

    -   Elements can be different types and different structures

    -   Including other lists! (i.e. *nested list*)

    -   Elements can be named

```{r}
listylist <- list(3, "42", "hello!", c(3,4,5))
listylist[[4]]
```

## a list of vectors == a data frame

```{r echo=F}
library(knitr)
library(dplyr)
```

```{r}
people <- data.frame(
  name = c("Alice", "Spew", "Charlemagne", "Kay", "Mackenzie", "Spirulina", "Jason"),
  age = c(25, 16, 42, 18, 3, 16, 20),
  humor_score = c(7, 14, 16, 9, 1, 20, 11),
  humor_category = c("Bad", "Good", "Good", "Bad", "Terrible", "Too Good", "Good")
)
kable(people)
```

## Logical vectors

-   In logical vectors, each element can be either `TRUE`, `FALSE`, or `NA`

-   Logical vectors are used in many functions which you've seen, like `filter()`

    -   `filter()` creates a logical vector based on your logical statement(s) and keeps all rows with `TRUE`

-   In the `filter()` example where we chose my besties, this is what we essentially did:

::: columns
::: {.column width="50%"}
```{r}
funny_adults <- people %>%
  mutate(is_adult = age > 18,
         is_funny = humor_category == "Good")
funny_adults
```
:::

::: {.column width="50%"}
```{r}
besties <- filter(funny_adults,
                  is_adult & is_funny)
besties
```

(what if we wanted to keep everyone who were adults *or* funny?
:::
:::

## %in%

-   `%in%` keeps all cases that match one of the elements in the vector.

-   It's useful when you have several possible matches and don't want to use multiple logical arguments.

```{r}
# Filter cases where name is either Alice, Kay, Jason, or Spirulina
filtered_people <- people %>%
  filter(name %in% c("Alice", "Kay", "Jason", "Spirulina"))

kable(filtered_people)
```

# Conditionals

## Mutating values conditionally

```{r}
?dplyr::mutate
?dplyr::case_when
```

-   Often, we want to change values in a variable differently depending on the value.

    -   i.e., we want to change values *conditionally*

-   We use `if_else()` inside `mutate(`) to do this:

```{r}
people <- people %>%
  mutate(adult_status = if_else(age >= 18, "Adult", "Minor"))
```

## if_else()

-   The syntax of `if_else()` is:

```{r, eval=F, highlight=F}
mutate(output_variable = if_else(conditional statement,
                                 value if true,
                                 value if false)
       )
```

-   We use `if_else` to check for only **one** condition.

-   What if we have multiple conditions?

    -   We would need multiple `if_else` statements

## if_else() with multiple conditions

-   What if we want to make a new variable reflecting the decade of life people are in, so we can group them by decade?

::: columns
::: {.column width="50%"}
```{r, eval=FALSE}
people <- people %>%
  mutate(decade_of_life = 
           if_else(age < 10, "0-9",
             if_else(age < 20, "10-19",
               if_else(age < 30, "20-29",
                 if_else(age < 40, "30-39",
                   if_else(age < 50, "40-49", 
                           "50+"
                   )
                 )
               )
             )
           )
  )
```
:::

::: {.column width="50%"}
::: {style="font-size: .7em"}
```{r, echo=FALSE}
people <- people %>%
  mutate(decade_of_life = 
           if_else(age < 10, "0-9",
             if_else(age < 20, "10-19",
               if_else(age < 30, "20-29",
                 if_else(age < 40, "30-39",
                   if_else(age < 50, "40-49", 
                           "50+"
                   )
                 )
               )
             )
           )
  )
kable(people)
```
:::
:::
:::

```{r}

```

-   This is horribly ugly :(

-   In comes `case_when()` to save the day!

## case_when()

```{r}
?dplyr::mutate
?dplyr::case_when
```

-   `case_when()` can be used within `mutate()` to *selectively* mutate values within a variable.
-   It is **extremely** useful to use with `mutate()` when you have multiple conditions and you want to assign different values or perform different operations based on those conditions.

::: columns
::: {.column width="50%"}
```{r, eval=FALSE}
# Create a new variable 'decade_of_life' 
# for which decade of life people are in
people <- people %>%
  mutate(decade_of_life = 
          case_when(
          age < 10 ~ "0-9",
          age < 20 ~ "10-19",
          age < 30 ~ "20-29",
          age < 40 ~ "30-39",
          age < 50 ~ "40-49",
          TRUE ~ "50+"
          )
  )
```
:::

::: {.column width="50%"}
::: {style="font-size: .7em"}
```{r, echo=FALSE}
# Create a new variable 'decade_of_life' 
# for which decade of life people are in
people <- people %>%
  mutate(decade_of_life = case_when(
    age < 10 ~ "0-9",
    age < 20 ~ "10-19",
    age < 30 ~ "20-29",
    age < 40 ~ "30-39",
    age < 50 ~ "40-49",
    TRUE ~ "50+"
  ))

# View the updated data frame
knitr::kable(people)
```
:::
:::
:::

## case_when()

-   In technical terms, `case_when()` is a **vectorized if-else statement**, in which an if-else statement is a way to perform conditional operations.

    -   Each argument in case_when takes the format of `conditional statement ~ output value`.

    -   The conditions are evaluated in order, and the first condition that evaluates to TRUE will have its corresponding value returned.

::: {.callout-tip appearance="minimal"}
In case_when statements, if none of the cases match, the output is NA *unless* you add a `TRUE ~ "misc_value"` case at the end. Thinking about how this works (why do you need only TRUE as a conditional statement) will help you understand `case_when` and conditional statements in general.
:::

## General if-else statements

-   `if_else()` is an R function which reflects general if-else statements, which are very common in programming

-   For analyzing data using Tidyverse functions, you will usually use `if_else` or `case_when`

-   However, if you start coding more complex things, you will want to use **general if-else statements**

    -   You can put **anything** in the conditions!

    -   They are used for **control flow** in a function or script

```{r}
classify_adult <- function(age) {
  if (age >= 18) {
    return("Adult")
  } else {
    return("Non-Adult")
  }
}

ben <- 29
classify_adult(ben)
```

# Iteration in R

-   Iteration means to do the same thing over and over again.

-   **For loops** are a very common way to do this in programming

-   R has the **apply** and **map** families of functions, which are vectorized for loops

## For Loops

-   **For loops** allow you to iterate over a sequence (vector) and perform actions for each item in the sequence

-   Let's print the name and age of each person in the `people` dataframe:

::: columns
::: {.column width="33%"}
[**manual iteration**]{.underline}

```{r, eval=F}
print(paste("Name:", people$name[1], ", Age:", people$age[1]))
print(paste("Name:", people$name[1], ", Age:", people$age[1]))
print(paste("Name:", people$name[2], ", Age:", people$age[2]))
print(paste("Name:", people$name[3], ", Age:", people$age[3]))
print(paste("Name:", people$name[4], ", Age:", people$age[4]))
print(paste("Name:", people$name[5], ", Age:", people$age[5]))
print(paste("Name:", people$name[6], ", Age:", people$age[6]))
print(paste("Name:", people$name[7], ", Age:", people$age[7]))
```
:::

::: {.column width="33%"}
[**OUTPUT**]{.underline}

```{r, echo=F}
for(i in 1:nrow(people)) {
  print(
    paste(
      "Name:", 
      people$name[i], 
      ", Age:", 
      people$age[i]))
}
```
:::

::: {.column width="33%"}
[**iteration using a for loop**]{.underline}

```{r, eval=F}
for(i in 1:nrow(people)) {
  print(
    paste(
      "Name:", 
      people$name[i], 
      ", Age:", 
      people$age[i]))
}
```
:::
:::

## For Loops

Here is the syntax of a **for loop:**

```{r, eval=F}
for(i in begin:end) {
  do something with i
}
```

-   *i* means the index; it is a variable that represents the index of each item in the sequence

-   However, I almost never use *for* loops in R!

-   Instead, I use vectorized functions like *map* or *apply* (*map* functions are in the Tidyverse and better than *apply*)

    -   They are more concise and readable

    -   They are more efficient

        -   `For` loops process each item/row sequentially

        -   Vectorized functions process multiple items/rows simultaneously

## The *map* family

```{r}
?purrr::map
```

Let's say we test all of the people in our dataset a bunch of times, and the number of times varies per person:

```{r echo=F}
set.seed(123)  # for reproducible example
people$scores <- list(rnorm(5, 70, 10), rnorm(3, 80, 15), rnorm(7, 65, 12), rnorm(4, 90, 5), rnorm(6, 85, 10), rnorm(5, 75, 10), rnorm(3, 90, 8))
kable(people)
```

We want the mean of scores for each person. Let's try this:

```{r}
mean(people$scores)
```

This doesn't work because `people$scores` is a list of vectors. We have to apply the `mean` function to *each vector* in the list, individually.

## The *map* family

We could do this with a for loop:

```{r}
# Create an empty vector to hold the results
average_score <- c()

# Loop over the rows of the data frame
for (i in 1:nrow(people)) {
  # Calculate the mean of the scores for the current person and save it in the results vector
  average_score[i] <- mean(people$scores[[i]])
}

# Add the results vector as a new column in the data frame
people$average_score <- average_score
```

Or with `map()`:

```{r}
library(purrr)
people$average_score <- map(people$scores, mean)
```

## map(), explained

-   `map()` applies a function to each element in a list or vector.

-   `for` loops are more flexible, but `map()` is simpler and works for most cases in R

-   It takes some practice to fully understand how to use *map()* for your data, so if you don't get it yet, don't worry!

-   Just keep this in mind and you'll come across it later when you're ready :)

## Last thing! Other *map()* functions

-   What's the class of the new average_score vector we just created?

```{r}
class(people$average_score)
```

-   `map()` always outputs a list for each value, even if it's a list of 1.

-   If you want the output to be a specific type, you have to use the right function

::: columns
::: {.column width="50%" style="text-align: center"}
| Function  | Type      |
|-----------|-----------|
| map_lgl() | logical   |
| map_int() | integer   |
| map_dbl() | numeric   |
| map_df()  | dataframe |
:::

::: {.column width="50%"}
```{r}
people$average_score <- map_dbl(people$scores, mean)
class(people$average_score)
```
:::
:::

# 
